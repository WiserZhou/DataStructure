// 二叉搜索树中节点的定义
typedef struct TreeNode
{
    // 假设在树节点结构中还有其他字段
    int data;                // 举例：数据字段
    struct TreeNode *lchild; // 左子节点
    struct TreeNode *rchild; // 右子节点
} *BSTree;

// 执行二叉搜索树左旋转的函数 RR
void LeftRotate(BSTree &p)
{
    // 保存节点p的右子节点
    BSTree rc = p->rchild;

    // 将rc的左子节点移到p的右子节点位置
    p->rchild = rc->lchild;

    // 将p作为rc的左子节点
    rc->lchild = p;

    // 更新p为rc，使rc成为修改后子树的新根节点
    p = rc;
}

// 执行二叉搜索树右旋转的函数 LL
void RightRotate(BSTree &p)
{
    // 保存节点p的左子节点
    BSTree lc = p->lchild;

    // 将lc的右子节点移到p的左子节点位置
    p->lchild = lc->rchild;

    // 将p作为lc的右子节点
    lc->rchild = p;

    // 更新p为lc，使lc成为修改后子树的新根节点
    p = lc;
}

// 在平衡二叉搜索树（AVL树）中，最小不平衡子树是指离插入或删除操作点最近的，且失去平衡条件的子树。这通常是在插入或删除操作后，从插入或删除点往根节点方向遍历，找到第一个不满足平衡条件的子树。

// 平衡二叉搜索树的平衡条件是：对于树中的每个节点，其左子树和右子树的高度差不超过1。

// 以下是查找最小不平衡子树的一般步骤：

// 1. 从插入或删除点开始，向上遍历直到根节点。
// 2. 在遍历的过程中，检查每个节点的平衡因子（左子树高度减去右子树高度的差值）是否超过1。
// 3. 如果发现某个节点的平衡因子超过1，说明这个节点所在的子树失去了平衡。
// 4. 此时，这个节点及其子树就是最小不平衡子树。

// 在这个过程中，因为我们是从下向上遍历，找到的第一个不平衡节点就是距离插入或删除点最近的不平衡节点，也就是最小不平衡子树的根节点。

// 一旦找到最小不平衡子树，就可以通过旋转操作来恢复平衡，通常分为左旋转、右旋转、左右旋转、右左旋转等情况，具体的操作取决于不平衡子树的结构。
