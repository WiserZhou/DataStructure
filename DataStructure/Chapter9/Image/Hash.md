# 哈希表

哈希表（Hash Table）是一种数据结构，用于实现关联数组（Associative Array）或映射（Map）这样的抽象数据类型。它通过将键（Key）映射到
表中的一个位置来实现高效的数据检索。哈希表的关键思想是使用哈希函数将键映射到一个确定的位置，该位置通常称为哈希桶或哈希槽。

在哈希表中，通过哈希函数计算键的哈希值，然后将该哈希值映射到数组中的一个索引。理想情况下，每个键都应该有唯一的哈希值，但由于哈
希函数的限制以及数组大小的有限性，可能会出现多个键映射到相同的索引的情况，这就是哈希冲突。
拉链法（Chaining）和开放地址法（Open Addressing）是解决散列冲突的两种主要方法。

## 拉链法，链地址法

1. **基本思想**：将散列表的每个槽（桶）维护一个链表，当发生冲突时，将冲突的关键字插入到对应槽的链表中。

2. **冲突处理**：在查找时，通过散列函数计算关键字的散列值，然后在对应槽的链表中搜索目标关键字。在插入时，同样通过散列函数计算散列值，然后将关键字插入到对应槽的链表中。

3. **优点**：
   - 简单易实现。
   - 适用于频繁的插入和删除操作。

4. **缺点**：
   - 内存空间利用率较低，因为每个槽都需要维护一个链表。
   - 链表长度过长可能导致性能下降，需要进行动态调整。

## 开放地址法

1. **基本思想**：在发生冲突时，通过一定的探测方法找到下一个可用的槽，直到找到空槽或者遍历整个散列表。

2. **冲突处理**：有多种探测方法，包括线性探测、二次探测、双重散列等。线性探测就是顺序地检查下一个槽，二次探测则使用二次方程，双重散列使用第二个散列函数来计算步长。

3. **优点**：
   - 内存空间利用率较高，没有额外的链表存储开销。
   - 适用于静态数据集，插入次数不多的情况。

4. **缺点**：
   - 删除操作较为复杂，可能需要标记已删除的槽。
   - 容易出现聚集，即多个关键字映射到相邻的槽，影响性能。

### 选择方法

- **拉链法适用于**：
  - 需要支持高负载因子（大量关键字）的情况。
  - 频繁的插入和删除操作。

- **开放地址法适用于**：
  - 静态数据集或负载因子相对较小的情况。
  - 对内存利用率有较高要求的情况。

选择拉链法还是开放地址法取决于具体的应用场景和对性能的要求。
直接定址法（Direct Addressing）是一种解决哈希冲突的简单而直接的方法。在这种方法中，每个关键字都与一个唯一的地
址相对应，即直接使用关键字作为数组的索引。这就要求关键字的全域（可能的关键字集合）较小且连续。

直接定址法的优点是它在理想情况下（即关键字较小、连续且无冲突）具有常数时间的查找性能，因为直接使用关键
字作为数组索引，无需计算哈希值。然而，在实际情况下，由于关键字集合通常很大，且不一定是连续的，直接定址法的应用受到很大的限制。

如果关键字的全域很大，直接定址法会导致数组大小过大，造成空间浪费。此外，如果关键字不是连续的，直接定址法可能需要大量的空间来维护一个庞大的数组。

因此，直接定址法更适用于全域较小且连续的情况，例如一些特定场景下的小规模整数关键字的集合。

质数除余法（Prime Division Hashing）是一种哈希函数设计方法，常用于构建哈希表。它的基本思想是将关键字 \(k\) 除以一个质数 \(p\)，然后取余数作为哈希值。数学表达式为：

\[ h(k) = k \mod p \]

其中，\(p\) 是一个选定的质数。

具体步骤如下：

1. 选择一个质数 \(p\)，通常选择接近哈希表大小的质数。
2. 对于每个关键字 \(k\)，计算 \(h(k) = k \mod p\)，得到哈希值。

质数除余法的优点在于简单、容易实现，而且在一些情况下具有较好的性能。此方法的目标是将关键字均匀地散布到哈希表的各个位置，从而减小哈希冲突的可能性。

注意事项：

- 选择一个好的质数 \(p\) 对于性能很重要，通常建议选择接近表大小的质数，以便更均匀地分布关键字。
- 在实际应用中，质数除余法可能需要结合其他技术，例如开放寻址法或链地址法，以处理冲突。
- 在选择质数时，避免选择与常见因子（如 2 和 10）有关的质数，以防止产生不均匀的哈希分布。

质数除余法通常是构建哈希表时常用的一种方法，但它并不适用于所有情况，具体的哈希函数设计需要根据应用的特定要求和关键字集合来选择。

平方取中法是一种哈希函数设计方法，通常用于将关键字映射到哈希表的索引。它的基本思想是将关键字的平方值取中间若干位作为哈希值。

具体步骤如下：

1. **选择关键字：** 选择一个整数作为关键字。
2. **计算平方：** 将关键字的平方计算出来。
3. **取中位数：** 取平方值的中间若干位作为哈希值。中间位数的选择通常是取平方值的中间几位或者是通过某种方式选择中间的几位数字。

这个方法的目标是通过对关键字进行平方操作，使得哈希值更加均匀地分布在整个哈希表范围内，从而降低哈希冲突的概率。

虽然平方取中法是一种简单的哈希函数设计方法，但需要注意的是：

- 在实际应用中，选择适当的位数取中对于哈希函数的性能和均匀分布至关重要。
- 对于较小的哈希表，可能需要通过试验和调整来选择合适的位数取中。
- 平方取中法的性能可能不如一些更复杂的哈希函数设计方法，特别是当关键字的分布不均匀时。

在选择哈希函数时，需要根据具体的应用场景和关键字的特性来决定使用哪种哈希函数设计方法。

```C++
int Hash(int key) {
// 假 设 key是 4 位 整 数
  key*=key；//求平方
  key=key/100；
//去掉末尾的两位数
  key=key%1000;
  return key；
}
```

处理冲突的方法，特别是在使用开放定址法解决冲突时的几种常见方法。以下是对每种方法的总结：

1. **线性探测再散列法：**
   - 冲突发生时，通过线性递增的方式来寻找下一个可用的散列地址。
   - 探查序列为 \(h_i(k) = (h(k) + i) \mod n\)，其中 \(n\) 是散列表的长度，\(i\) 从 1 到 \(n-1\)。

2. **二次探测再散列法：**
   - 冲突发生时，通过二次递增的方式来寻找下一个可用的散列地址。
   - 探查序列为 \(h_i(k) = (h(k) + di) \mod n\)，其中 \(di\) 是一组固定的增量，通常为 \(di = 1^2, -1^2, 2^2, -2^2, \ldots, k^2, -k^2\)，确保探查序列不会在 \(n\) 之内重复。

3. **伪随机探测再散列法：**
   - 使用一个伪随机序列作为增量来进行探查，以减少冲突的可能性。
   - 探查序列为 \(h_i(k) = (h(k) + di) \mod n\)，其中 \(di\) 是一个伪随机序列。

4. **再哈希法（再散列法）：**
   - 使用多个哈希函数来处理冲突，如果一个哈希函数产生冲突，就顺序尝试下一个哈希函数。
   - 设定多个哈希函数 \(RH_0, RH_1, \ldots, RH_k\)，当一个哈希函数产生冲突时，顺序切换到下一个哈希函数。

哈希表的查找算法的平均查找长度（Average Search Length，ASL）是衡量哈希表性能的重要指标之一。ASL 反映了在哈希表中进行查找操作时所需的平均步骤数。

考虑一个大小为 \(m\) 的哈希表，其中有 \(n\) 个关键字被散列到表中。哈希表的负载因子 \( \lambda \) 定义为 \( \lambda = \frac{n}{m} \)，表示平均每个槽位存储的关键字数。

假设哈希函数是均匀分布的，即每个关键字被散列到任何一个槽位的概率都是相等的。在这种情况下，我们可以通过平均查找长度的期望值来分析哈希表的性能。

### 平均查找长度的期望值

1. **线性探测法：**
   - \( \text{ASL} = \frac{1}{2} (1 + \frac{1}{1-\lambda}) \)

2. **二次探测法：**
   - \( \text{ASL} = \frac{1}{2} \left(1 + \frac{1}{1-\lambda}\right)^2 \)

3. **链地址法：**
   - \( \text{ASL} = 1 + \frac{\lambda}{2} \)
  
4. **双散列法：**
   - \( \text{ASL} = \frac{1}{2} \left(1 + \frac{1}{1-\lambda}\right) \)

这些公式描述了在不同的开放定址法和链地址法中平均查找长度的期望值。在分析中，通常关注的是负载因子 \( \lambda \) 对平均查找长度的影响。较小的负载因子通常导致更低的平均查找长度，但过小的负载因子可能浪费存储空间，而过大的负载因子可能导致冲突增多，影响性能。

要根据实际情况选择合适的哈希函数和解决冲突的方法，以优化哈希表的性能。
